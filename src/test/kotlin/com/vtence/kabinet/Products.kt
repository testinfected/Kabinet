package com.vtence.kabinet

import com.natpryce.hamkrest.*


data class Product(
    val id: Int? = null,
    val number: Int,
    var name: String,
    var description: String? = null
) {
    override fun toString(): String {
        return "$number ($name)"
    }
}

object Products : Table("products") {
    val id = int("id").autoGenerated()
    val number = int("number")
    val name = string("name")
    val description = string("description").nullable()
}


private fun Products.dehydrate(st: DataSet, product: Product) {
    st[number] = product.number
    st[description] = product.description
    st[name] = product.name
}

private fun Products.hydrate(row: ResultRow): Product {
    return Product(
        id = row[id],
        number = row[number],
        name = row[name],
        description = row[description]
    )
}

val Product.record: Dehydrator<Products>
    get() = { dehydrate(it, this@record) }

val ResultRow.product: Product
    get() = Products.hydrate(this)

fun ResultRow.product(alias: String): Product = rebase(Products.alias(alias)).product


object ProductThat {
    fun hasSameStateAs(other: Product) =
        hasId(other.id) and
                hasNumber(other.number) and
                hasName(other.name) and
                hasDescription(other.description)

    fun hasId(id: Int?) = has(Product::id, equalTo(id))
    fun hasNumber(number: Int) = has(Product::number, equalTo(number))
    fun hasName(name: String) = hasName(equalTo(name))
    fun hasName(matching: Matcher<String>) = has(Product::name, matching)
    fun hasDescription(description: String?) = has(Product::description, equalTo(description))
    fun hasDescription(matching: Matcher<String?>) = has(Product::description, matching)
}
