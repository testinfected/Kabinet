package com.vtence.kabinet


interface FieldSet : Expression {
    val source: ColumnSet

    val fields: List<Field<*>>
}


interface ColumnSet: FieldSet {
    val columns: List<Column<*>>

    override val fields: List<Field<*>> get() = columns
}

fun List<Column<*>>.autoGenerated() = filter { it.autoGenerated }

fun List<Column<*>>.notAutoGenerated() = filterNot { it.autoGenerated }


open class Table(name: String): ColumnSet {
    val tableName = name
    private val _columns = mutableListOf<Column<*>>()

    override val source: ColumnSet get() = this
    override val columns: List<Column<*>> get() = _columns

    override fun appendTo(sql: SqlBuilder) {
        sql.append(tableName)
    }

    fun int(name: String): Column<Int> = add(Column(this, name, IntColumnType))

    fun string(name: String): Column<String> = add(Column(this, name, StringColumnType))

    private fun <T> add(column: Column<T>): Column<T> = column.also { _columns += it }

    fun replaceColumn(old: Column<*>, new: Column<*>): Unit = with(_columns) {
        remove(old)
        add(new)
    }
}


class Slice(override val source: ColumnSet, override val fields: List<Field<*>>) : FieldSet {
    override fun appendTo(sql: SqlBuilder) {
        sql.append(source)
    }
}

class Projection(override val source: Table, override val columns: List<Column<*>>) : ColumnSet {
    override fun appendTo(sql: SqlBuilder) {
        sql.append(source)
    }
}

fun Table.slice(field: Field<*>, vararg more: Field<*>): FieldSet = slice(listOf(field) + more)

fun Table.slice(fields: List<Field<*>>): FieldSet = Slice(this, fields)

fun Table.slice(column: Column<*>, vararg more: Column<*>): ColumnSet = slice(listOf(column) + more)

fun Table.slice(columns: List<Column<*>>): ColumnSet = Projection(this, columns)
